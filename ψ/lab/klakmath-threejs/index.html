<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KlakMath + Three.js Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    KlakMath + Three.js<br>
    Click to move target<br>
    Camera follows with spring physics
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============================================
    // KlakMath (ported to JS)
    // ============================================

    class XXHash {
      static PRIME32_2 = 0x85ebca77;
      static PRIME32_3 = 0xc2b2ae3d;
      static PRIME32_4 = 0x27d4eb2f;
      static PRIME32_5 = 0x165667b1;

      constructor(seed = 0) {
        this.seed = seed >>> 0;
      }

      hash(data) {
        let h32 = (this.seed + XXHash.PRIME32_5) >>> 0;
        h32 = (h32 + 4) >>> 0;
        h32 = (h32 + Math.imul(data >>> 0, XXHash.PRIME32_3)) >>> 0;
        h32 = ((h32 << 17) | (h32 >>> 15)) >>> 0;
        h32 = Math.imul(h32, XXHash.PRIME32_4) >>> 0;
        h32 ^= h32 >>> 15;
        h32 = Math.imul(h32, XXHash.PRIME32_2) >>> 0;
        h32 ^= h32 >>> 13;
        h32 = Math.imul(h32, XXHash.PRIME32_3) >>> 0;
        h32 ^= h32 >>> 16;
        return h32;
      }

      float(data) {
        return this.hash(data) / 0xffffffff;
      }

      floatRange(min, max, data) {
        return min + this.float(data) * (max - min);
      }

      onSphere(data) {
        const phi = this.floatRange(0, Math.PI * 2, data);
        const z = this.floatRange(-1, 1, data + 0x10000000);
        const w = Math.sqrt(1 - z * z);
        return new THREE.Vector3(Math.cos(phi) * w, Math.sin(phi) * w, z);
      }
    }

    class Noise {
      static float(p, seed = 0) {
        const hash = new XXHash(seed);
        const i = Math.floor(p) + 0x10000000;
        const x = p - Math.floor(p);

        let k0 = 1 - x * x;
        let k1 = 1 - (1 - x) * (1 - x);
        k0 = k0 * k0 * k0;
        k1 = k1 * k1 * k1;

        const g0 = hash.floatRange(-1, 1, i);
        const g1 = hash.floatRange(-1, 1, i + 1);

        const n = k0 * g0 * x + k1 * g1 * (x - 1);
        return n * 2 * 32 / 27;
      }

      static fractal(p, octaves = 4, seed = 0) {
        let f = 0, w = 1;
        for (let i = 0; i < octaves; i++) {
          f += w * this.float(p, seed + i);
          p *= 2;
          w *= 0.5;
        }
        return f;
      }
    }

    class CdsTween {
      static step(x, v, target, speed, dt) {
        const n1 = v - (x - target) * (speed * speed * dt);
        const n2 = 1 + speed * dt;
        const nv = n1 / (n2 * n2);
        return { x: x + nv * dt, v: nv };
      }

      static stepVec3(pos, vel, target, speed, dt) {
        const rx = this.step(pos.x, vel.x, target.x, speed, dt);
        const ry = this.step(pos.y, vel.y, target.y, speed, dt);
        const rz = this.step(pos.z, vel.z, target.z, speed, dt);
        return {
          pos: new THREE.Vector3(rx.x, ry.x, rz.x),
          vel: new THREE.Vector3(rx.v, ry.v, rz.v)
        };
      }
    }

    // ============================================
    // Three.js Scene
    // ============================================

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111122);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Grid
    const grid = new THREE.GridHelper(20, 20, 0x444466, 0x333344);
    scene.add(grid);

    // Target marker (red sphere)
    const targetGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const targetMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0x441111 });
    const targetMesh = new THREE.Mesh(targetGeo, targetMat);
    scene.add(targetMesh);

    // Noise-animated particles (XXHash deterministic)
    const hash = new XXHash(42);
    const particles = [];
    const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);

    for (let i = 0; i < 50; i++) {
      const color = new THREE.Color().setHSL(hash.float(i * 100), 0.7, 0.5);
      const mat = new THREE.MeshStandardMaterial({ color, emissive: color.clone().multiplyScalar(0.2) });
      const mesh = new THREE.Mesh(particleGeo, mat);

      const basePos = hash.onSphere(i).multiplyScalar(4);
      mesh.userData.basePos = basePos.clone();
      mesh.userData.seed = i;
      mesh.position.copy(basePos);

      particles.push(mesh);
      scene.add(mesh);
    }

    // Camera spring state
    let camTarget = new THREE.Vector3(0, 2, 0);
    let camVel = new THREE.Vector3(0, 0, 0);
    const camOffset = new THREE.Vector3(0, 5, 10);

    // Click to move target
    const raycaster = new THREE.Raycaster();
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

    renderer.domElement.addEventListener('click', (event) => {
      const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );
      raycaster.setFromCamera(mouse, camera);
      const point = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, point);
      if (point) {
        camTarget.copy(point);
        targetMesh.position.copy(point);
      }
    });

    // Animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update particles with noise
      particles.forEach((p, i) => {
        const noiseX = Noise.fractal(time * 0.3 + i * 0.1, 3, i);
        const noiseY = Noise.fractal(time * 0.4 + i * 0.2, 3, i + 1000);
        const noiseZ = Noise.fractal(time * 0.35 + i * 0.15, 3, i + 2000);

        p.position.x = p.userData.basePos.x + noiseX * 0.5;
        p.position.y = p.userData.basePos.y + noiseY * 0.5 + 2;
        p.position.z = p.userData.basePos.z + noiseZ * 0.5;
      });

      // Camera follows target with spring physics
      const targetCamPos = camTarget.clone().add(camOffset);
      const result = CdsTween.stepVec3(camera.position, camVel, targetCamPos, 3, dt);
      camera.position.copy(result.pos);
      camVel.copy(result.vel);
      camera.lookAt(camTarget);

      renderer.render(scene, camera);
    }

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
